var tipuesearch = {"pages":[{"title":"Building Python extension modules for C++ code with pybind11","text":"Introduction If you ever needed to provide interface to the C/C++ code from your Python modules, you may have used Python extension modules . They are typically created when there is an existing C++ project and it is required to make it accessible via Python bindings. Alternatively, when performance becomes critical, a certain part of the Python project can be written in C/C++ and made accessible to the rest of the Python codebase via some kind of interface. Quite a few large C++ libraries and frameworks have associated Python bindings – they can be used for prototyping or simply to speed up the development as writing a Python program is supposed to take less time than writing an equivalent C++ program. Exposing your library interface with another popular language, such as Python, will also make your project more accessible for programmers who are not very familiar with C++. Refer to excellent RealPython: Python Bindings: Calling C or C++ From Python article to learn more. Python bindings There are quite a few options on how you can make your C++ code accessible from Python. However, I have personally worked only with SWIG and pybind11 so far. For now, let's focus on pybind11 . It's extremely easy to set up on Linux or Windows and you should be able to create a compiled Python extension module ( .so for Linux and .pyd for Windows) very quickly. The pybind11 documentation does provide excellent reference information with a ton of examples. However, those examples often demonstrate features in isolation and I thought it would be useful to share an example of a more complete \"library\" where multiple examples are combined into something that looks like a MVP. Writing C++ code Here is the C++ file, Geometry.cpp , I've written to demonstrate the pybind11 features. It showcases constructing custom Point class instances, finding the distance between them in 2D and 3D space, and overloading C++ comparison operators among a few other things. #include <pybind11/pybind11.h> #include <pybind11/operators.h> #include <string> #include <sstream> #include <iomanip> #include <cmath> namespace py = pybind11 ; using namespace std ; class Point { public : Point ( const double & x , const double & y ) : x ( x ), y ( y ) { z = numeric_limits < double >:: quiet_NaN (); py :: print ( \"Constructing a point with z set to nan\" ); } Point ( const double & x , const double & y , const double & z ) : x ( x ), y ( y ), z ( z ) { py :: print ( \"Constructing a point with z set to a user given value\" ); } double x ; double y ; double z ; string shapeType = \"Point\" ; double distanceTo ( Point point , bool in3D ) { if ( in3D ) { if ( ! isnan ( z ) && ! isnan ( point . z )) { return sqrt ( pow (( point . x - x ), 2 ) + pow (( point . y - y ), 2 ) + pow (( point . z - z ), 2 )); } else { py :: print ( \"Cannot measure distance between points in XY and XYZ space\" ); return numeric_limits < double >:: quiet_NaN (); } } else { return sqrt ( pow (( point . x - x ), 2 ) + pow (( point . y - y ), 2 )); } } bool static areEqual ( Point left , Point right ) { if ( isnan ( left . z ) && isnan ( right . z )) { return left . y == right . y && left . x == right . x ; } else if ( isnan ( left . z ) &#94; isnan ( right . z )) { return false ; } else { return left . y == right . y && left . x == right . x && left . z == right . z ; } } friend bool operator == ( const Point & left , const Point & right ) { return areEqual ( left , right ); } friend bool operator != ( const Point & left , const Point & right ) { return ! areEqual ( left , right ); } bool is3D () const { return ! isnan ( z ); } }; PYBIND11_MODULE ( Geometry , m ) { m . doc () = \"C++ toy geometry library\" ; py :: class_ < Point > ( m , \"Point\" , \"Point shape class implementation\" ) . def ( py :: init < const double & , const double &> (), py :: arg ( \"x\" ), py :: arg ( \"y\" )) . def ( py :: init < const double & , const double & , const double &> (), py :: arg ( \"x\" ), py :: arg ( \"y\" ), py :: arg ( \"z\" )) . def_readonly ( \"x\" , & Point :: x ) . def_readonly ( \"y\" , & Point :: y ) . def_readonly ( \"z\" , & Point :: z ) . def_readonly ( \"shapeType\" , & Point :: shapeType ) . def ( \"distanceTo\" , & Point :: distanceTo , py :: arg ( \"point\" ), py :: arg ( \"in3D\" ) = false , \"Distance to another point\" ) . def ( \"is3D\" , & Point :: is3D , \"Whether a point has a valid z coordinate\" ) . def ( py :: self == py :: self ) . def ( py :: self != py :: self ) . def ( \"__repr__\" , []( const Point & point ) { stringstream xAsString , yAsString , zAsString ; xAsString << std :: setprecision ( 17 ) << point . x ; yAsString << std :: setprecision ( 17 ) << point . y ; zAsString << std :: setprecision ( 17 ) << point . z ; if ( point . z != 0 ) { return \"Point (\" + xAsString . str () + \", \" + yAsString . str () + \", \" + zAsString . str () + \")\" ; } else { return \"Point (\" + xAsString . str () + \", \" + yAsString . str () + \")\" ; } }); } Building a Python extension module Once you have the Geometry.cpp file on disk and pybind11 installed, you should be able to compile the C++ code and link it to the Python headers: $ c++ -O3 -Wall -shared -std = c++11 -fPIC ` python3 -m pybind11 --includes ` Geometry.cpp -o Geometry ` python3-config --extension-suffix ` If you are not very familiar with Bash, command in the backticks in the command above are evaluated by the shell before the main command. The python3 -m pybind11 --includes part is used to get the location of Python header files and the python3-config --extension-suffix part is used to get the suffix for the shared library name – for CPython 3.6 on a 64bit Ubuntu, the Geometry.cpython-36m-x86_64-linux-gnu.so file will be created. Now, once you have the shared library file, it can be imported and used pretty much as if it was a regular Python module. Using a Python extension module Let's see our library in action by running the file python3 use_geometry.py containing the code below: import math from Geometry import Point # runtime dispatch of init constructors print ( Point . __init__ . __doc__ ) # a method signature and its docstring print ( Point . distanceTo . __doc__ ) p1 = Point ( 10 , 20 ) p2 = Point ( 20 , 30 ) p3 = Point ( 20 , 30 ) p4 = Point ( 50 , 60 , 45.67 ) p5 = Point ( 50 , 60 , 45.67 ) assert p1 . distanceTo ( p2 ) == math . sqrt ( 200 ) # check operator overloading works assert p1 != p2 assert p2 == p3 assert not p2 != p3 assert p4 == p5 assert not p4 == p3 assert math . isnan ( p1 . z ) # check distance between 3D points p1 = Point ( 50 , 60 , 45 ) p2 = Point ( 50 , 60 , 75 ) print ( p1 . distanceTo ( p2 , in3D = True )) # check __repr__ print ( p1 ) print ( p2 ) The produced output: __init__(*args, **kwargs) Overloaded function. 1. __init__(self: Geometry.Point, x: float, y: float) -> None 2. __init__(self: Geometry.Point, x: float, y: float, z: float) -> None distanceTo(self: Geometry.Point, point: Geometry.Point, in3D: bool = False) -> float Distance to another point Constructing a point with z set to nan Constructing a point with z set to nan Constructing a point with z set to nan Constructing a point with z set to a user given value Constructing a point with z set to a user given value Constructing a point with z set to a user given value Constructing a point with z set to a user given value Distance between Point (50, 60, 45) and Point (50, 60, 75) is 30.0 Representation of the p1 is \"Point (50, 60, 45)\" Representation of the p2 is \"Point (50, 60, 75)\" This is of course a very trivial example of pybind11 usage, however there have been successful attempts to use pybind11 for binding existing large C++ libraries such as CGAL and Point Cloud Library . See an example of wrapping some of the CGAL functionality with pybind11 and Python bindings for the Point Cloud Library to learn more. Happy binding!","tags":"python","url":"/pybind11-python-bindings.html","loc":"/pybind11-python-bindings.html"},{"title":"What I think a great tech support should look like","text":"Being a software engineer implies that you may be interacting with customers particularly if you are working in a small company. If you wearing multiple hats or if you are in professional services or tech support, you will likely be contacted by your customers about issues they may experience using your product – a web site, a desktop or a mobile app, or some hardware equipment. Whatever it is, I believe it's best to have a clear plan of actions outlined which you can follow when addressing a customer's issue. No matter how fine-grained your protocol of communication with the customer already is, you can always incorporate some of the ideas I have about how I'd like to work with a customer that needs help. I do understand that it may be difficult or unrealistic to follow the steps below exactly, but this is my vision of a great support. Customer gets in touch Customer reaches out to you because some functionality on the web site of a business system your team built doesn't work as they expect. Pace yourself Do not attempt to provide any solution or ask any questions just yet. If your guess will be accurate – you ask to enable JavaScript in a web browser or to log out and log back in – the customer is less likely to share any details with you because they can now continue working. You, on the other hand, are missing a chance to document the incident to see if it would be possible to prevent it from happening again and to share it with your team members. What was the version of the web browser where the JavaScript is not enabled by default? Did they really have to log out and log back in or a simple refresh of a web page would be enough (you may tweak server-side caching settings)? You may never figure this out and even though the problem is \"solved\" and the customer is happy, in the long run this was a lost. Show empathy No matter what channel of communication is being used – a phone call or an email – the first thing you do is to show some empathy: being an engineer, you know better than anyone how frustrating it can be when a computer doesn't do what you want it to do. Collect information You can start collecting the information you will need to troubleshoot now; don't ask for information you can collect yourself, but sometimes it may still be useful – even if you can SSH into a server to get the version of a software installed, it would still be very useful to ask the customer to tell you the version they see on the web page as an older version may indicate a web page caching issue. You would ideally have a pre-defined template document where you can fill all the information you may need so that you don't have think about it during a phone call. Share information Once you have gathered all the information, make sure to share it with the customer. If on the phone, read it back to them. If it's an email conversation, either share the complete document or provide access to the internal support system (if any) where they would be able to check that the information they've shared with you is accurate. This will help to avoid any misunderstandings and provide traceability as the customer will acknowledge that the information they have provided is correct. Doing troubleshooting Depending on how urgent the request is, you may or may not have time to do some manual production inspection before telling the customer how to fix their problem. If they are in a middle of a presentation to a board of directors, it may be best to tell them how to fix the issue immediately. If it is not time critical, you may want to ask for some time to log in into the production environment to record as much as information as you possibly can. For instance, they told you that they are still able to use the system despite not being logged in. Instead of telling them to log off and log in hoping it will fix the problem (did you know that hope is not a strategy ?), you may want to log in into the server to find out what's going on with your authentication service while the user hasn't left their web browser session (provided you don't do any verbose logging of this type of events already). This issue may indicate some serious problem that is worth investigating further because it may manifest itself again at some point. Update on the progress If the problem requires more time and you will likely need to spend hours if not days working on it, it's best to let the customer know about the progress. They would be able to find it very helpful to see that you are working on their issue and ideally how much time you've spent (a support ticket can be \"in progress\" for 5 days, but the engineer may have been working on it for just 1 hour). Provide a temporary solution if applicable If it's an option, make sure to provide customer with a workaround to let them continue to do their business. If they need to process some files, offer to do it manually for them if possible. If their business operation depends on a feature from their \"basic\" plan that doesn't work and you know that an alternative feature from the \"advanced\" plan would work, upgrade their account for some time while you are troubleshooting. Tell about proposed solution Once you have identified the issue and have been able to solve it, tell the user what was happening and what you have done to solve it. Adjust the language depending on how technical things get as required but don't be afraid to offer them a chance to learn; many customers would find it helpful to understand how the product they use operate under the hood. Ask them to verify that the solution you've implemented works for them (after you have done everything you possibly could to verify this yourself first). Document your findings After you found the resolution to a problem, make sure to document not only what has to be done to fix it, but also what have you attempted to get done which didn't seem to help. For instance, you thought that the problem may be due to a broken database table index and have decided to re-build it. That didn't help and then you think that perhaps recalculating the table statistics may help. You do that now and, yes, the problem is gone. However, documenting that for this problem recalculating the table statistics is necessary may be misleading as re-building the table index may also be required. When you or a colleague of yours will be reading the incident documentation, they will know what have you attempted before finding the solution. Wherever possible, any changes to any environment should be happening via code or a terminal to make it easy to record as making changes in the GUIs are generally known to be very hard to document. A problem that can be solved purely by customers themselves (invalidating the web browser cache or to change some setting within the user interface of the business system itself) is a great candidate to be added into the user documentation. Happy supporting!","tags":"tech-support","url":"/my-version-of-a-great-tech-support.html","loc":"/my-version-of-a-great-tech-support.html"}]};